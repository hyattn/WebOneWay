<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aframe with Three.js in AR</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r124/build/three.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r124/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <a-scene 
        embedded
        arjs="sourceType: webcam; debugUIEnabled: false;"
    >
        <!-- Camera -->
        <a-entity 
            id="camera"
            camera 
            look-controls
            position="0 0 0"
        ></a-entity>

        <!-- Lights -->
        <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
        <a-light type="directional" color="#ffffff" intensity="0.8" position="20 30 0" castShadow="true"></a-light>

        <!-- 3D Model -->
        <a-entity 
            gltf-model="./dist/HospitalModelAddRooms.gltf"
            class="clickable"
        ></a-entity>

        <!-- Pathfinding helper -->
        <a-entity 
            pathfinding-helper
        ></a-entity>

        <!-- AR Button -->
        <a href="https://immersiveweb.dev/" style="position: absolute; top: 10px; right: 10px; z-index: 9999;">AR Mode</a>
    </a-scene>

    <script>
        AFRAME.registerComponent('pathfinding-helper', {
            init: function () {
                const scene = this.el.sceneEl.object3D;
                const loader = new THREE.GLTFLoader();
                const pathfinding = new THREE.Pathfinding();
                let navmesh;

                loader.load('./dist/HospitalModelAddRooms.NavMeshgltf.gltf', function (gltf) {
                    scene.add(gltf.scene);
                    gltf.scene.traverse((node) => {
                        if (!navmesh && node.isMesh) {
                            navmesh = node;
                            const geometry = node.geometry;
                            pathfinding.setZoneData('level1', THREE.Pathfinding.createZone(geometry));

                            // Start point (for fixed navigation)
                            const startPoint = new THREE.Vector3(0, 0, 0);
                            // End point (for fixed navigation)
                            const endPoint = new THREE.Vector3(5, 0, 5);
                            const groupID = pathfinding.getGroup('level1', startPoint);
                            const closest = pathfinding.getClosestNode(startPoint, 'level1', groupID);
                            const navpath = pathfinding.findPath(closest.centroid, endPoint, 'level1', groupID);
                            if (navpath) {
                                const pathfindingHelper = document.querySelector('[pathfinding-helper]');
                                pathfindingHelper.setAttribute('draw-path', { path: navpath });
                            }
                        }
                    });
                });

                // Commented out click event listener
                /*this.el.sceneEl.addEventListener('click', (event) => {
                    const intersects = event.detail.intersectedEls;
                    if (intersects.length > 0) {
                        const targetPosition = intersects[0].object3D.position;
                        const cameraPosition = document.getElementById('camera').object3D.position;
                        const groupID = pathfinding.getGroup('level1', cameraPosition);
                        const closest = pathfinding.getClosestNode(cameraPosition, 'level1', groupID);
                        const navpath = pathfinding.findPath(closest.centroid, targetPosition, 'level1', groupID);
                        if (navpath) {
                            const pathfindingHelper = document.querySelector('[pathfinding-helper]');
                            pathfindingHelper.setAttribute('draw-path', {
                                playerPosition: cameraPosition,
                                targetPosition: targetPosition,
                                path: navpath
                            });
                        }
                    }
                });*/
            }
        });

        AFRAME.registerComponent('draw-path', {
            schema: {
                path: { type: 'array' }
            },
            init: function () {
                const scene = this.el.sceneEl.object3D;
                const lineGeometry = new THREE.BufferGeometry();
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);

                this.update();
            },
            update: function () {
                const navpath = this.data.path;
                const points = navpath.map(node => new THREE.Vector3(node.x, node.y, node.z));
                const geometry = this.el.getObject3D('mesh').geometry;
                geometry.setFromPoints(points);
            }
        });
    </script>
</body>
</html>
